A. Задача на равенство
ограничение по времени на тест: 2 seconds
ограничение по памяти на тест: 256 megabytes

Компания из \(n\) веселых программистов отмечает день рождения Роберта Флойда. Поликарпу досталась почетная обязанность — разливать Бер-Колу. Очень важно разлить Бер-Колу поровну, то есть так, чтобы объем напитка в каждой из \(n\) кружек оказался одинаков.

Поликарп уже начал процесс, частично опустошив бутылку Бер-Колы. Сейчас в первой кружке \(a_1\) миллилитров напитка, во второй — \(a_2\) миллилитра и т.д. В бутылке осталось \(b\) миллилитров, которые Поликарп собирается распределить между кружками так, чтобы выполнялось заветное равенство.

Напишите программу, которая определит объем напитка, который надо долить в каждую из кружек, чтобы следующие два условия выполнялись одновременно:

\(\bull\) суммарно было разлито \(b\) миллилитров, то есть чтобы бутылка была опустошена;
\(\bull\) после окончания процесса объемы напитка в кружках должны быть равны.

Входные данные
В первой строке записана пара целых чисел \(n, b (2 ≤ n ≤ 100, 1 ≤ b ≤ 100)\), где \(n\) — общее число друзей в компании, а \(b\) — текущий объем напитка в бутылке. Вторая строка содержит последовательность целых чисел \(a_1, a_2, ..., a_n (0 ≤ a_i ≤ 100)\), где \(a_i\) — текущий объем напитка в \(i\)-ой кружке.

Выходные данные
Выведите единственное число «-1» (без кавычек), если решения не существует. В противном случае выведите n вещественных чисел \(c_1, c_2, ..., c_n\), где \(c_i\) — объем напитка, который надо долить в \(i\)-ую кружку. Числа выводите не менее чем с 6 знаками после десятичной точки, каждое \(c_i\) выводите на отдельной строке. Поликарп доказал, что если решение существует, то оно единственно.

На тестирующем компьютере по умолчанию установлена русская локаль. Убедитесь, что ваше решение выводит точку для отделения целой части вещественного числа от дробной, а не запятую.




В данный момент имеется \(n\) кружек, и \(i\)-я кружка содержит \(a_i\) миллилитров напитка. 
Необходимо распределить \(b\) миллилитров между \(n\) кружками так, чтобы после распределения каждая кружка содержала одинаковое количество напитка.

Общее количество напитка:
\(
\text{totalAmount} = a_1 + a_2 + \dots + a_n + b
\)

Так как это значение должно быть равномерно распределено между \(n\) кружками, количество напитка в каждой кружке должно быть:
\(
\text{finalAmountOfEachMug} = \frac{\text{totalAmount}}{n}
\)

Распределения можно описать следующим образом:
1. Выбрем индекс \(i\).
2. Определить количество \(c_i\), которое нужно добавить в \(i\)-ю кружку.
3. Уменьшим \(b\) на \(c_i\) и увеличим \(a_i\) на \(c_i\) (\(0 \leq c_i \leq b\)).

Мы можем либо увеличить либо не трогать \(a_i\), уменьшить - не можем.

Таким образом, если для некоторого \(i\): \(a_i > \text{finalAmountOfEachMug}\), то очевидно, что это невозможно.

В противном случае это возможно. В этом случае можно добавить \((\text{finalAmountOfEachMug} - a_i)\) в \(i\)-ю кружку, чтобы увеличить \(a_i\) до \(\text{finalAmountOfEachMug}\).





#include<bits/stdc++.h>

using namespace std;
using DO = double;

const int NN = 121;

DO a[NN], b;

int main() {
    
    int n; scanf("%d %lf", &n, &b);
    for(int i = 1; i <= n; i++) scanf("%lf", a + i);
}




Посчитаем \(\text{totalAmount}\) и \(\text{finalAmountOfEachMug}\).




#include<bits/stdc++.h>

using namespace std;
using DO = double;

const int NN = 121;

DO a[NN], b;

int main() {
    
    int n; scanf("%d %lf", &n, &b);
    for(int i = 1; i <= n; i++) scanf("%lf", a + i);
    
    DO totalAmount = b;
    for(int i = 1; i <= n; i++) totalAmount += a[i];
    
    DO finalAmountOfEachMug = totalAmount / n;
}




Проверим, существует ли такой \(i\), что \(a_i > \text{finalAmountOfEachMug}\).  
Если да, это означает, что решения не существует, поэтому выведем "\(-1\)" и закончим.





#include<bits/stdc++.h>

using namespace std;
using DO = double;

const int NN = 121;

DO a[NN], b;

int main() {
    
    int n; scanf("%d %lf", &n, &b);
    for(int i = 1; i <= n; i++) scanf("%lf", a + i);
    
    DO totalAmount = b;
    for(int i = 1; i <= n; i++) totalAmount += a[i];
    
    DO finalAmountOfEachMug = totalAmount / n;
    
    for(int i = 1; i <= n; i++) if(a[i] > finalAmountOfEachMug) {
        puts("-1"); return 0;
    }
}




В противном случае, необходимо добавить \((\text{finalAmountOfEachMug} - a_i)\) в \(i\)-ю кружку, чтобы увеличить \(a_i\) до \(\text{finalAmountOfEachMug}\).  
Таким образом, мы можем вывести это значение для каждой кружки.




#include<bits/stdc++.h>

using namespace std;
using DO = double;

const int NN = 121;

DO a[NN], b;

int main() {
    
    int n; scanf("%d %lf", &n, &b);
    for(int i = 1; i <= n; i++) scanf("%lf", a + i);
    
    DO totalAmount = b;
    for(int i = 1; i <= n; i++) totalAmount += a[i];
    
    DO finalAmountOfEachMug = totalAmount / n;
    
    for(int i = 1; i <= n; i++) if(a[i] > finalAmountOfEachMug) {
        puts("-1"); return 0;
    }
    
    for(int i = 1; i <= n; i++) {
        printf("%.6lf\n", finalAmountOfEachMug - a[i]);
    }
}




5 50
1 2 3 4 5




2 2
1 100




Рассмотрим граничный случай, когда \(n\) - минимальное а \(b\) и \(a_i\) имеют максимальные значения:

\(
2 \, 100 \\
100 \, 100
\)

У нас есть 2 кружки, каждая из которых изначально содержит 100 миллилитров, и нужно равномерно распределить 100 миллилитров.

\(
\text{totalAmount} = a_1 + a_2 + \dots + a_n + b = 100 + 100 + 100 = 300
\)
\(
\text{finalAmountOfEachMug} = \frac{\text{totalAmount}}{n} = \frac{300}{2} = 150
\)

Следовательно, необходимо добавить 50 миллилитров в каждую кружку.





2 100
100 100