D. Слонопотамы
ограничение по времени на тест: 1 секунда
ограничение по памяти на тест: 256 мегабайт

Слонопотам — фигура, состоящая из трёх клеток, образующих «уголок». Эту фигуру можно поворачивать на 90, 180 и 270 градусов, так что получаются 4 возможных положения:

<code>
XX   XX   .X   X.
X.   .X   XX   XX
</code>

Слонопотамы — мирные фигуры, в отличие от классических шахматных фигур, они не бьют никакие клетки, два слонопотама могут стоять даже рядом друг с другом — главное, чтобы они занимали разные клетки.

У Васи есть доска 2×n клеток, на которой он хочет разместить несколько слонопотамов. К сожалению, часть клеток доски уже заняты пешками, на эти клетки ставить другие фигуры нельзя. С другой стороны, пешки дружат со слонопотамами, поэтому тоже не бьют слонопотамов, даже если они стоят рядом.

Зная расположение пешек на доске, подскажите Васе, какое наибольшее количество слонопотамов он может одновременно разместить на доске так, чтобы они не пересекались друг с другом и не занимали клетки с пешками.

Входные данные
Входной файл содержит две непустые строки, задающие доску Васи. Строки состоят только из символов «0» (ноль), обозначающих свободные клетки доски, и символов «X» (заглавная латинская буква), соответствующих клеткам, занятым пешками. Строки непустые, имеют одинаковую длину, не превышающую 100.

Выходные данные
Вывести единственное число — наибольшее количество слонопотамов, которое можно разместить на заданной доске.




Чтобы решить задачу размещения максимального количества слонопотамов на доске 2×n с пешками, можно использовать рекурсивный метод, который перебирает все возможные конечные результаты. Слонопотам может быть размещён в четырёх ориентациях, каждая из которых занимает три клетки в форме "L". Доска представлена двумя строками, где '0' обозначает пустые клетки, а 'X' — клетки, занятые пешками.

Рекурсивная функция будет проверять каждую клетку на возможность размещения слонопотама, учитывая все ориентации. Если размещение возможно, мы помечаем занятые клетки и рекурсивно вызываем функцию для следующей позиции. Этот процесс продолжается до тех пор, пока не будут обработаны все клетки, после чего мы сравниваем количество размещённых слонопотамов и обновляем максимальное значение.

Хотя этот подход позволяет исследовать все конфигурации, он может привести к превышению лимита времени из-за экспоненциальной сложности.




Мы можем решить эту задачу, используя динамическое программирование. Пусть \( dp[i][j][k] \) представляет максимальное количество слонопотамов, которые могут быть размещены на первых \( i \) столбцах, где \( j \) и \( k \) указывают на состояние \( i \)-го столбца после оптимального размещения слонопотамов на отрезке \([1..i]\).
После оптимального размещения слонопотамов, если верхний элемент \( i \)-го столбца является частью слонопотама, то \( j = 1 \); в противном случае \( j = 0 \). Если нижний элемент \( i \)-го столбца является частью слонопотама, то \( k = 1 \); в противном случае \( k = 0 \).

Изначально мы не разместили ни одного слонопотама, поэтому \( dp[0][0][0] = 0 \), а все остальные состояния \( dp[i][j][k] \) равны \(-\infty\).

Теперь давайте рассмотрим возможные переходы:
1. Для состояния \( dp[i][1][1] \):
   - \( dp[i][1][1] = \max(dp[i][1][1], \max(dp[i - 1][0][0], dp[i - 1][0][1]) + 1) \): если верхняя клетка \( (i-1) \)-го столбца и обе клетки \( i \)-го столбца свободны, мы можем разместить слонопотама, используя нижнюю клетку \( (i-1) \)-го столбца.
   - \( dp[i][1][1] = \max(dp[i][1][1], \max(dp[i - 1][0][0], dp[i - 1][1][0]) + 1) \): аналогично, если нижняя клетка \( (i-1) \)-го столбца и обе клетки \( i \)-го столбца свободны.
2. Для состояния \( dp[i][0][1] \):
   - \( dp[i][0][1] = \max(dp[i][0][1], \max(dp[i - 2][0][0], dp[i - 2][0][1], dp[i - 2][1][0], dp[i - 2][1][1]) + 1) \): если обе клетки \( (i-1) \)-го столбца свободны и нижняя клетка \( i \)-го столбца свободна, мы можем разместить слонопотама, используя верхнюю клетку \( (i-1) \)-го столбца.
3. Для состояния \( dp[i][1][0] \):
   - \( dp[i][1][0] = \max(dp[i][1][0], \max(dp[i - 2][0][0], dp[i - 2][0][1], dp[i - 2][1][0], dp[i - 2][1][1]) + 1) \): аналогично, если обе клетки \( (i-1) \)-го столбца свободны и верхняя клетка \( i \)-го столбца свободна.
4. Для состояния \( dp[i][0][0] \):
   - \( dp[i][0][0] = \max(dp[i][0][0], \max(dp[i - 1][0][0], dp[i - 1][0][1], dp[i - 1][1][0], dp[i - 1][1][1])) \): если обе клетки \( i \)-го столбца заняты, мы просто берём максимальное количество слонопотамов, размещённых на предыдущем столбце.

В конечном итоге, ответ будет максимальным значением из \( \max(dp[n][0][0], dp[n][0][1], dp[n][1][0], dp[n][1][1]) \), что даст нам максимальное количество слонопотамов, которые могут быть размещены на всей доске.

Временная сложность данного алгоритма составляет \( O(n) \), где \( n \) — это количество столбцов на доске.




#include<bits/stdc++.h>
using namespace std;

char s[2][121];

int main() {
    scanf("%s %s", s[0] + 1, s[1] + 1);
    return 0;
}




Пусть \( dp[i][j][k] \) представляет максимальное количество слонопотамов, которые могут быть размещены на первых \( i \) столбцах, где \( j \) и \( k \) указывают на состояние \( i \)-го столбца после оптимального размещения слонопотамов на отрезке \([1..i]\). После оптимального размещения слонопотамов, если верхний элемент \( i \)-го столбца является частью слонопотама, то \( j = 1 \); в противном случае \( j = 0 \). Если нижний элемент \( i \)-го столбца является частью слонопотама, то \( k = 1 \); в противном случае \( k = 0 \).

Изначально мы не разместили ни одного слонопотама, поэтому \( dp[0][0][0] = 0 \), а все остальные состояния \( dp[i][j][k] \) равны \(-\infty\).




#include<bits/stdc++.h>
using namespace std;

int n;
int dp[121][2][2];
char s[2][121];

int main() {
    scanf("%s %s", s[0] + 1, s[1] + 1);
    n = strlen(s[0] + 1);
    for (int i = 0; i <= n; ++i) {
        for (int j = 0; j < 2; ++j) {
            for (int k = 0; k < 2; ++k) {
                dp[i][j][k] = INT_MIN;
            }
        }
    }
    dp[0][0][0] = 0;
    return 0;
}




1. Для состояния \( dp[i][1][1] \):
   - \( dp[i][1][1] = \max(dp[i][1][1], \max(dp[i - 1][0][0], dp[i - 1][0][1]) + 1) \): если верхняя клетка \( (i-1) \)-го столбца и обе клетки \( i \)-го столбца свободны, мы можем разместить слонопотама, используя нижнюю клетку \( (i-1) \)-го столбца.
   - \( dp[i][1][1] = \max(dp[i][1][1], \max(dp[i - 1][0][0], dp[i - 1][1][0]) + 1) \): аналогично, если нижняя клетка \( (i-1) \)-го столбца и обе клетки \( i \)-го столбца свободны.
   
   
   
   
   #include<bits/stdc++.h>
using namespace std;

int n;
int dp[121][2][2];
char s[2][121];

int main() {
    scanf("%s %s", s[0] + 1, s[1] + 1);
    n = strlen(s[0] + 1);
    for (int i = 0; i <= n; ++i) {
        for (int j = 0; j < 2; ++j) {
            for (int k = 0; k < 2; ++k) {
                dp[i][j][k] = INT_MIN;
            }
        }
    }
    dp[0][0][0] = 0;

    for (int i = 1; i <= n; ++i) {
        char UL = s[0][i - 1], UR = s[0][i];
        char DL = s[1][i - 1], DR = s[1][i];
        
        if(UL == '0' && UR == '0' && DR == '0') dp[i][1][1] = max(dp[i][1][1], max(dp[i - 1][0][0], dp[i - 1][0][1]) + 1);
        if(DL == '0' && UR == '0' && DR == '0') dp[i][1][1] = max(dp[i][1][1], max(dp[i - 1][0][0], dp[i - 1][1][0]) + 1);
    }
    return 0;
}




2. Для состояния \( dp[i][0][1] \):
   - \( dp[i][0][1] = \max(dp[i][0][1], \max(dp[i - 2][0][0], dp[i - 2][0][1], dp[i - 2][1][0], dp[i - 2][1][1]) + 1) \): если обе клетки \( (i-1) \)-го столбца свободны и нижняя клетка \( i \)-го столбца свободна, мы можем разместить слонопотама, используя верхнюю клетку \( (i-1) \)-го столбца.
   
   
   
   
   #include<bits/stdc++.h>
using namespace std;

int n;
int dp[121][2][2];
char s[2][121];

int main() {
    scanf("%s %s", s[0] + 1, s[1] + 1);
    n = strlen(s[0] + 1);
    for (int i = 0; i <= n; ++i) {
        for (int j = 0; j < 2; ++j) {
            for (int k = 0; k < 2; ++k) {
                dp[i][j][k] = INT_MIN;
            }
        }
    }
    dp[0][0][0] = 0;

    for (int i = 1; i <= n; ++i) {
        char UL = s[0][i - 1], UR = s[0][i];
        char DL = s[1][i - 1], DR = s[1][i];
        
        if(UL == '0' && UR == '0' && DR == '0') dp[i][1][1] = max(dp[i][1][1], max(dp[i - 1][0][0], dp[i - 1][0][1]) + 1);
        if(DL == '0' && UR == '0' && DR == '0') dp[i][1][1] = max(dp[i][1][1], max(dp[i - 1][0][0], dp[i - 1][1][0]) + 1);

        if(UL == '0' && DL == '0' && DR == '0') dp[i][0][1] = max(dp[i][0][1], max({dp[i - 2][0][0], dp[i - 2][0][1], dp[i - 2][1][0], dp[i - 2][1][1]}) + 1);
    }
    return 0;
}




3. Для состояния \( dp[i][1][0] \):
   - \( dp[i][1][0] = \max(dp[i][1][0], \max(dp[i - 2][0][0], dp[i - 2][0][1], dp[i - 2][1][0], dp[i - 2][1][1]) + 1) \): аналогично, если обе клетки \( (i-1) \)-го столбца свободны и верхняя клетка \( i \)-го столбца свободна.
   
   
   
   
   #include<bits/stdc++.h>
using namespace std;

int n;
int dp[121][2][2];
char s[2][121];

int main() {
    scanf("%s %s", s[0] + 1, s[1] + 1);
    n = strlen(s[0] + 1);
    for (int i = 0; i <= n; ++i) {
        for (int j = 0; j < 2; ++j) {
            for (int k = 0; k < 2; ++k) {
                dp[i][j][k] = INT_MIN;
            }
        }
    }
    dp[0][0][0] = 0;

    for (int i = 1; i <= n; ++i) {
        char UL = s[0][i - 1], UR = s[0][i];
        char DL = s[1][i - 1], DR = s[1][i];
        
        if(UL == '0' && UR == '0' && DR == '0') dp[i][1][1] = max(dp[i][1][1], max(dp[i - 1][0][0], dp[i - 1][0][1]) + 1);
        if(DL == '0' && UR == '0' && DR == '0') dp[i][1][1] = max(dp[i][1][1], max(dp[i - 1][0][0], dp[i - 1][1][0]) + 1);

        if(UL == '0' && DL == '0' && DR == '0') dp[i][0][1] = max(dp[i][0][1], max({dp[i - 2][0][0], dp[i - 2][0][1], dp[i - 2][1][0], dp[i - 2][1][1]}) + 1);
        if(UL == '0' && DL == '0' && UR == '0') dp[i][1][0] = max(dp[i][1][0], max({dp[i - 2][0][0], dp[i - 2][0][1], dp[i - 2][1][0], dp[i - 2][1][1]}) + 1);
    }
    return 0;
}




4. Для состояния \( dp[i][0][0] \):
   - \( dp[i][0][0] = \max(dp[i][0][0], \max(dp[i - 1][0][0], dp[i - 1][0][1], dp[i - 1][1][0], dp[i - 1][1][1])) \): если обе клетки \( i \)-го столбца заняты, мы просто берем максимальное количество слонопотамов, размещенных на предыдущем столбце.
   
   
   
   
   #include<bits/stdc++.h>
using namespace std;

int n;
int dp[121][2][2];
char s[2][121];

int main() {
    scanf("%s %s", s[0] + 1, s[1] + 1);
    n = strlen(s[0] + 1);
    for (int i = 0; i <= n; ++i) {
        for (int j = 0; j < 2; ++j) {
            for (int k = 0; k < 2; ++k) {
                dp[i][j][k] = INT_MIN;
            }
        }
    }
    dp[0][0][0] = 0;

    for (int i = 1; i <= n; ++i) {
        char UL = s[0][i - 1], UR = s[0][i];
        char DL = s[1][i - 1], DR = s[1][i];
        
        if(UL == '0' && UR == '0' && DR == '0') dp[i][1][1] = max(dp[i][1][1], max(dp[i - 1][0][0], dp[i - 1][0][1]) + 1);
        if(DL == '0' && UR == '0' && DR == '0') dp[i][1][1] = max(dp[i][1][1], max(dp[i - 1][0][0], dp[i - 1][1][0]) + 1);

        if(UL == '0' && DL == '0' && DR == '0') dp[i][0][1] = max(dp[i][0][1], max({dp[i - 2][0][0], dp[i - 2][0][1], dp[i - 2][1][0], dp[i - 2][1][1]}) + 1);
        if(UL == '0' && DL == '0' && UR == '0') dp[i][1][0] = max(dp[i][1][0], max({dp[i - 2][0][0], dp[i - 2][0][1], dp[i - 2][1][0], dp[i - 2][1][1]}) + 1);
        
        dp[i][0][0] = max(dp[i][0][0], max({dp[i - 1][0][0], dp[i - 1][0][1], dp[i - 1][1][0], dp[i - 1][1][1]}));
    }
    return 0;
}




Итоговым ответом является максимальное значение \( \max(dp[n][0][0], dp[n][0][1], dp[n][1][0], dp[n][1][1]) \), что дает нам максимальное количество слонопотамов, которое может быть размещено на всей доске.




#include<bits/stdc++.h>
using namespace std;

int n;
int dp[121][2][2];
char s[2][121];

int main() {
    scanf("%s %s", s[0] + 1, s[1] + 1);
    n = strlen(s[0] + 1);
    for (int i = 0; i <= n; ++i) {
        for (int j = 0; j < 2; ++j) {
            for (int k = 0; k < 2; ++k) {
                dp[i][j][k] = INT_MIN;
            }
        }
    }
    dp[0][0][0] = 0;

    for (int i = 1; i <= n; ++i) {
        char UL = s[0][i - 1], UR = s[0][i];
        char DL = s[1][i - 1], DR = s[1][i];
        
        if(UL == '0' && UR == '0' && DR == '0') dp[i][1][1] = max(dp[i][1][1], max(dp[i - 1][0][0], dp[i - 1][0][1]) + 1);
        if(DL == '0' && UR == '0' && DR == '0') dp[i][1][1] = max(dp[i][1][1], max(dp[i - 1][0][0], dp[i - 1][1][0]) + 1);

        if(UL == '0' && DL == '0' && DR == '0') dp[i][0][1] = max(dp[i][0][1], max({dp[i - 2][0][0], dp[i - 2][0][1], dp[i - 2][1][0], dp[i - 2][1][1]}) + 1);
        if(UL == '0' && DL == '0' && UR == '0') dp[i][1][0] = max(dp[i][1][0], max({dp[i - 2][0][0], dp[i - 2][0][1], dp[i - 2][1][0], dp[i - 2][1][1]}) + 1);
        
        dp[i][0][0] = max(dp[i][0][0], max({dp[i - 1][0][0], dp[i - 1][0][1], dp[i - 1][1][0], dp[i - 1][1][1]}));
    }
    
    printf("%d\n", max({dp[n][0][0], dp[n][0][1], dp[n][1][0], dp[n][1][1]}));
    return 0;
}




00
00




00X00X0XXX0
0XXX0X00X00





0X0X0
0X0X0




0XXX0
00000




Рассмотрим пользовательский угловой случай, в котором \(n\) находится на минимальном значении: \(n = 1\).

0
0

В этом случае мы не можем разместить слонопотама, так как его ширина равна 2. Следовательно, ответ будет "0".




0
0